include::../_settings_deck.adoc[]
// include::../../_settings_reveal.adoc[]

= Git and GitHub

== What problems do we face as a Software Developers?

* Backups of a project at different states. 
** after we solve a bug?
** before trying out a new feature?
* Working on a team, how
** do we manage which copy is the __central__ version if each developer works in its own?
** can we allow for more than one developer to work in the same file?
**  can we track what changes have been done by each developer?


== Version Control Systems (VCS)

* A complete long-term change history of every file 
** Creation, edition and deletion of files

* Revert files to previous states
* Revert entire projects back to previous states
* Compare changes over time
* Branching and mergin
** Individuals working on independent streams of changes
** Enables to verify that the changes on each branch do not conflict
* Traceability
** Trace each change made to the software by each contributor
** Connect it to project management and bug tracking software such https://www.web.com[JIRA].

== Different flavors:

* Non-Existing, provably what some of you are doing right now
* Local(here), like 
* Centralized(there), CVS or Subversion (also known as SVN)
* Distributed(both), like Git

image::resources/flavors.jpeg[flavors]

//In summary a Version Control System allows you to easily recover //former working states if you screw things up or lose files.

== What is Git?

* By far, the most widely used modern version control system in the world.
* Is a mature, actively maintained open source project originally developed in 2005 by https://www.wikipedia.com/linux[Linus Torvalds](Linux operating system kernel)

* An example of a DVCS:
** Everything is local
** Is really fast
** Snapshots, not diffs
** Distributed not centralized

== Installing Git

* **Windows**: [https://git-scm.com/download/win](https://git-scm.com/download/win)
* **Mac**: [https://git-scm.com/download/mac](https://git-scm.com/download/mac)

Then we check the installation by checking git's version: 

`$ git --version`

Possible outputs:

* `git version 2.6.4`
* `bash: git: command not found`


== Configuring Git:

- Our **identity**, so every time we make a commit, it is associated to our person:

[source, bash]
----
$ git config --global user.name "your name"
$ git config --global user.email your.email@propulsion.ch
----
- The **editor** to be used if git wants to show us something:

[source, bash]
----
git config --global core.editor <vim, emacs, subl, atom....>
git config --global core.editor "subl -n -w"
git config --global core.editor "atom --wait" 
----
- Enable **color** in git, so the outputs will be easier to read:

[source, bash]
----
git config --global color.ui auto
----
- Check all the settings:

[source, bash]
----
git config --list
----
  
== Git workflow

In a Git repository a file can be in one of these three states:

* Modified: When you modify files in your working directory
* Staged: You stage the files, adding a snapshot of them to the staging area
* Commited: You do a commit that stores snapshots permanently to your GIt directory

image::./resources/lifecycle.png[lifecycle]

== Git basic operations (I)

* To create a new Git project:
** `git init`
** `git clone /path/to/repo`

* See state of the repository:
** `git status`

* Add new files to staging area:
** `git add <filename>`
** `git add *`

* Commit changes:
** `git commit -m "Commit message"`

== Git basic operations (II)

* To see the history of a repo:
** `git log`
** `git lop -n <number>`
** `git log --stat`
** `git log --pretty=oneline`

* See changes in a commit:
** `git show <commitID>`

* or compare two commits:
** `git diff commit1ID commit2ID`

* Revert to previous state:
** `git checkout <commitID>`
* or return to current state:
** `git checkout master`

== Example I

1. Create a new repo.
2. Add some files
3. Stage them
4. Modify one file
5. Check state of the repo
6. Commit changes
7. Repeat the process for other files
8. Go back to a previous state.
9. Inspect the directory.
10. What files did git added?
** .gitignore
** ./git


== Branchhing
Branches are used to develop features isolated from each other:

* The **master** branch is the "default" branch when you create a repository.

* We use other branches for development and merge them back to the master branch upon completition.

image::resources/branching.jpg[branching]


== Operations

* To list all branches:
** `git branch`

* To create a new branch:
** `git branch <new_branch_name>`

* To switch to a different branch:
** `git checkout <other_branch_name>`

* To create and swith to a new branch:
** `git checkout -b <new_branch_name>`

* To delete a branch:
** `git branch -d <branch_name>`

* To merge branches:
** `git merge <branch_a> <branch_b>`

== Problems with branches

Sometimes auto-merge is not possible and the result are *conflicts*. 

* Master and another branch modify the same file.

So we are responsible to merge those conflicts manually by editing the files shown by git. 

* Editor of choice.
* **Tip**: Before mergin changes, preview changes.
** `git diff`


== EXAMPLE II

* New branch
** Navigate between branches and see state of both
* Make modifications in the branch and in the master
** Merge branch into master
* Generate a conflict
** Solve it

== Working with remote repositories

description

== Operations

* To send these canges to your remote repository:
** `git push origin master`

* or to a particular branch:
** `git push origin branch_name`

== Origin

When creating a new repository:

* By convention the name it recives the new remote repository(GitHub).
* No requirement to name the remote repository this way.
* It could be multimple remote repositories.

When cloning a repo for the first time:

* It is the default name fiven to the original remote repository that you clone. It is where
you want to pull and push changes.


== Branching
A branch is not available to others unless you push the branch to your remote repository
* `git push origin branch_name`

== EXAMPLE III

== GitHub


== EXAMPLE IV

== GitHub Pages
== Project

== Personal recommendation

* Visual Studio code

